## Definition
在作業系統教科書之間有聖經之稱的「Operating System Concepts （恐龍本）」中，對死結（Deadlock）的定義如下：
> 在**多重程式設計（multiprogramming）的環境中，多個執行緒（threads）可能會競爭有限的資源。當某個執行緒請求資源時，若該資源當下無法取得，該執行緒便會進入等待狀態（waiting state）**。有時候，某個等待中的執行緒可能**永遠無法改變其狀態**，因為它所請求的資源被**其他同樣處於等待狀態的執行緒所持有**。

以較為直觀的角度來看的話可以這樣理解：
> 在作業系統中，死結是指：當一個行程（process）或執行緒（thread）進入等待狀態時，其所要求的系統資源被另一個處於等待狀態的行程所持有，而那個行程又在等待另一個資源，該資源則被另一個等待中的行程持有，形成一連串相互等待的狀態。如果一個行程**無法永遠改變其狀態**，原因是它所要求的資源**被另一個同樣處於等待狀態的行程佔用**，那麼就稱系統進入了**死結狀態（deadlock state）**。

### A Simple Example
例如，一個行程 $\text{P1}$ 占用了顯示器，同時又必須使用印表機，而印表機被行程 $\text{P2}$ 占用，$\text{P2}$ 又必須使用顯示器，這樣就形成了死結。 因為 $\text{P1}$ 必須等待 $\text{P2}$ 釋出印表機才能夠完成工作並釋出螢幕，同時 $\text{P2}$ 也必須等待 $\text{P1}$ 釋出顯示器才能完成工作並釋出印表機，形成循環等待的死結。

![](https://upload.wikimedia.org/wikipedia/commons/thumb/2/28/Process_deadlock.svg/440px-Process_deadlock.svg.png)
$\text{P1}$、$\text{P2}$ 兩個 process 都需要資源才能繼續執行。$\text{P1}$ 擁有資源 $\text{R2}$、還需要額外資源 $\text{R1}$ 才能執行；$\text{P2}$ 擁有資源 $\text{R1}$、還需要額外資源 $\text{R2}$ 才能執行，兩邊都在互相等待而沒有任何一個可執行。

另外一個有關於死結的經典問題是[[Dining Philosophers Problem|哲學家就餐問題]]。

## Necessary Conditions
要讓死結發生，必須同時滿足以下四個充分必要條件：
這四個條件有時候會被稱為科夫曼條件（Coffman Conditions）。
1. **互斥（Mutual Exclusion）**
    至少有一個資源是在不可分享狀態下被佔用。也就是說，一次只能有一個 thread 可以使用資源。如果其他 thread 想要使用這項資源，就只能等到這項資源被使用者釋放。
2. **佔有等待（Hold and Wait）**
    一個 thread 手中必須已經持有一項資源，且，同時在等待另一項正在被其他 thread 使用的資源。
3. **不可搶奪（No Preemption, or Non-Preemption）**
    資源皆是不可被搶奪的。換句話說，就是資源只能在 thread 完成一個 task 後，以自願的方式釋放。
4. **循環等待（Circular Wait）**
    有一組正在等待資源的 threads $\{ T_0, T_1, \cdots, T_n\}$ ，滿足：
     - $T_0$ 在等待 $T_1$ 手中的資源
     - $T_1$ 在等待 $T_2$ 手中的資源
     - $\vdots$
     - $T_{n-1}$ 在等待 $T_n$ 手中的資源
     - $T_n$ 在等待 $T_0$ 手中的資源
    
    從上述描述來看，不難發現：此條件滿足時，代表佔有等待也必定滿足。（循環等待是佔有等待的充分條件）

若要解決死結問題，必須**破壞上述四個條件中的至少一個**。在實作中，某些方法會嘗試破壞「互斥」或「不可搶奪」的條件，以找到有效的解法；但在大多數理論性的探討中，這兩個條件通常被視為**不可妥協**（不可避免或必須維持的假設），因此解法通常會著重於破壞「資源保持」或「循環等待」這兩個條件（有時是同時破壞這兩個）。

## Deadlock Handling
對於死結的處理方式，可以大致歸類為以下三種：
1. 完全忽略這個問題，假裝系統中不會發生死結。
2. 採用某種協定（protocol）來預防或避免死結，以確保系統永遠不會進入死結狀態。
3. 允許系統進入死結狀態，然後再進行偵測與恢復。

### Ignoring Deadlock
忽略死結是大多數作業系統（包括 Linux 和 Windows）所採用的做法。這種情況下，就需要 Kernel 與應用程式開發者負責撰寫能夠處理死結的程式，這類程式通常會採用第二種解法中所提到的預防或避免方法。

為了**確保系統永遠不會發生死結**，可以採用死結預防（deadlock prevention）或死結避免（deadlock avoidance）的機制。

### Deadlock Prevention
死結預防提供了一套方法，用來確保死結發生所需的條件中，至少有一項無法成立。這些方法透過**限制資源請求的方式**來達到預防死結的目的。

> [!NOTE] TL;DR
> 避免循環等待是最實際且有效的解決方法。 詳見[[#Circular Wait]]。

#### Mutual Exclusion
互斥條件必須成立，也就是至少有一項資源是無法共享的。可共享的資源不需要互斥存取，因此無法導致死結。

像是唯讀檔案（read-only files）就是一種可共享資源。如果多個執行緒同時開啟一個唯讀檔案，它們可以被同時授予存取權限，不會互相阻塞。對於可共享的資源，執行緒永遠不需要等待。
  
然而，一般來說，**我們無法透過否定互斥條件來預防死結，因為某些資源本質上就是無法共享的**。例如：互斥鎖（Mutex lock） 無法被多個執行緒同時持有。

#### Hold and Wait
為了確保系統中永遠不會出現「佔有且等待」的情況，我們必須保證當執行緒請求資源時，它不持有任何其他資源。

有一種協定是：
>每個執行緒在開始執行之前，必須先請求並獲得它所需要的所有資源。
>但對大多數情況來說，這並不切實際，因為資源需求往往是動態變化的。

另一種協定則是：
>執行緒只能在完全沒有持有資源時才能請求資源。
>也就是說，執行緒可以請求一部分資源並使用；但在它要請求其他資源之前，必須先釋放它目前持有的所有資源。

然而，這兩種協定都有兩個主要缺點：
1. **資源使用率可能偏低**
    因為有些資源可能被分配出去，但長時間都沒被實際使用。例如，一個執行緒可能在整個執行期間都被分配了一把互斥鎖，但實際上只在某一小段時間內需要它。
2. **可能發生飢餓（Starvation）**
    如果一個執行緒需要多個熱門資源，它可能**一直等不到所有資源都可用**，因為其中至少有一個資源總是被其他執行緒佔用。

#### No Preemptive
死結的第三個必要條件是：**已經被分配的資源無法被搶奪。

為了讓這個條件不成立，我們可以採用以下協定：
> 如果某個執行緒目前**持有一些資源**，並且又請求**另一個目前無法立即分配的資源**（也就是說，它必須等待），那麼**它目前持有的所有資源都會被搶回**。

換句話說，這些資源會被**隱式釋放**，並被加入執行緒所等待的資源清單中。
這個執行緒**只有在它能夠一次性取得原本的資源加上新請求的資源時，才會重新啟動執行**。

另一種做法是這樣的：
> 當某個執行緒請求一些資源時，我們會先檢查這些資源是否可用：
> - 如果可用，就直接分配給它。
> - 如果不可用，我們再檢查這些資源是否**被某個正在等待其他資源的執行緒所持有**。
>     如果是這樣，我們會**從那個等待的執行緒手中搶下這些資源**，並分配給目前的請求者。
> - 如果這些資源**既不可用、也不是由等待中的執行緒持有**，那麼請求者就必須等待。
>     在等待的過程中，這個執行緒**本身持有的資源也可能會被其他執行緒搶走**，但**只有在有其他執行緒明確請求這些資源的情況下才會發生**。

一個執行緒只有在同時取得它新請求的資源，以及**所有在等待期間被搶走的資源**後，才會重新啟動。這種協定**通常適用於那些可以輕鬆儲存與還原狀態的資源**，例如 CPU 暫存器或資料庫交易（transactions）。但它**不太適用於像是互斥鎖（Mutex）或是信號量（Semaphore）這類資源**，而這些正是最容易發生死結的資源類型。

#### Circular Wait
前面介紹的三種防止死結的方法，在多數情況下都不太實用。然而，**死結的第四個必要條件 —— 循環等待（circular-wait）**，提供了一個更實際的解決方案：**讓這個條件不成立，就能有效預防死結**。

其中一種方式是：
> **對所有資源類型施加一個**「**總體排序（total ordering）**」，並要求每個執行緒只能按照這個排序，以**遞增的順序請求資源**。

為了說明這個方法，我們令資源集合為：$R = \{R_1, R_2, \cdots, R_m\}$。我們為集合中的每個資源類型指定一個唯一的整數編號，使我們能夠比較任意兩個資源，判斷它們在排序中的先後關係。形式上，我們定義一個一對一的函數：$F: R \rightarrow N$，其中 $N$ 是自然數集合。這個函數可以在應用程式中被實作，用來對系統中的所有同步物件建立一個排序。例如，對於以下 `Pthread` 程式中的鎖順序，我們可以定義：
```
F(first_mutex) = 1
F(second_mutex) = 5
```

接著，我們可以使用如下協定來防止死結：
> 每個執行緒只能**按照遞增的資源編號順序來請求資源**。也就是說，假設某執行緒首先請求資源 $R_j$，那麼它之後只能請求資源 $R_k$，前提是 $F(R_k) > F(R_j)$。

例如，根據上述函數定義，如果一個執行緒需要同時使用 `first_mutex` 與 `second_mutex`，那它必須**先請求 `first_mutex`，然後才能請求 `second_mutex`**。

另一種替代做法是：
> 若執行緒請求資源$R_j$，則它**不能持有任何滿足 $F(R_k) > F(R_j)$ 的資源 $R_k$。**

此外，如果執行緒**需要同一類資源的多個實例**，那麼它**必須一次性請求全部**。如果系統遵守上述兩種協定之一，就能保證**循環等待的條件不會成立**。

> [!TIP]- 為了展示以上內容的正確性，以下用反證法舉例證明：
> 假設某系統中存在一組陷入循環等待的執行緒集合：
> $T = \{T_0, T_1, \cdots, T_n\}$
> 
> 其中每個執行緒 $T_i$ 正在等待資源 $R_i$，而該資源被執行緒 $T_{i+1}$ 所持有
> （索引以模運算處理，即 $T_n$ 等同於 $T_0$ 的前一個）。
> 
> 由於 $T_{i+1}$ 正持有 $R_i$ 並請求 $R_{i+1}$，根據前述協定，我們必須有：
> $F(R_i) < F(R_{i+1}), \forall \space i$
> 
> 由遞移性，可以推得 ：
> $F(R_0) < F(R_n) < F(R_0)$
> 但是這在數學上是**不可能成立**的。
> 
> 因此推翻了原假設：**系統中不可能存在循環等待**。

> [!WARNING] 注意
> **僅僅建立這樣的資源排序（或資源階層）本身**並不能真正防止死結。最終仍然必須靠**應用程式開發者遵循這個順序編寫程式碼**。
> 
> 此外，也必須特別注意，即使我們對鎖設定了取得順序，若鎖是以動態方式取得的（例如在不同邏輯路徑或函式中動態請求），這樣的排序也不能保證完全避免死結。

但在實務上，這一點也頗具挑戰性。特別是在一個有數百甚至數千個鎖的系統中，要正確建立並遵守鎖順序是困難的。

### Deadlock Avoidance
死結預防是透過**限制資源請求的方式**來防止死結發生。這些限制的目的，是要確保**至少有一個造成死結的必要條件不成立**。
然而，這種方法的副作用可能包括：
- 裝置使用率低落
- 整體系統吞吐量（throughput）下降

 死結避免則要求作業系統事先獲得額外的資訊，包括每個執行緒在其整個生命週期中可能會請求與使用哪些資源。舉例來說，在一個有兩種資源 $R_1$ 與 $R_2$ 的系統中，系統可能需要知道以下資訊：
- 執行緒 $P$ 將會先請求 $R_1$，再請求 $R_2$，然後同時釋放它們
- 執行緒 $I$ 則是先請求 $R_2$，再請求 $R_1$

有了這類完整的資源請求與釋放序列資訊，系統就能夠判斷每次請求是否應該暫緩處理，以避免未來可能出現的死結情況。

每一次資源請求的處理，系統都必須考慮下列因素：
- 目前可用的資源有哪些
- 各執行緒目前已分配的資源為何
- 每個執行緒未來可能的請求與釋放行為

而這些因素，其實就是資源分配狀態（resource-allocation state）的定義：
- 目前可用的資源數量
- 各執行緒已分配到的資源
- 各執行緒宣告的最大資源需求
  
使用這種方法的各種演算法，在「所需資訊的數量與類型」上會有所不同。而最簡單且實用的一種模型是：
> 要求每個執行緒**事先宣告**它對各類資源**可能會需要的最大數量**

有了這個**先驗資訊（a priori information）**，我們就可以設計一套演算法，確保系統永遠不會進入死結狀態。這類死結避免演算法會**動態檢查資源分配狀態**，以確保不會發生循環等待的情形。

#### Safe State
如果系統可以按照某個順序，將資源分配給每個執行緒（最多到其宣告的最大需求量），且仍能避免死結，那這個狀態就稱為**安全狀態（safe state）**。更正式地說，系統處於安全狀態的條件是**存在至少一個安全序列（safe sequence）**。

假設目前的資源分配狀態為 $S$，若有一個執行緒序列 $<T_0, T_1, \cdots, T_n>$，滿足下列條件，則稱為一個「安全序列」：
> 對於序列中的每一個執行緒 $T_i$，它仍可能提出的所有資源需求，可以被目前系統中可用的資源，以及所有在它前面完成的執行緒所釋放的資源所滿足。

換句話說，如果 $T_i$ 所需的資源當下還沒辦法滿足，它可以先等待前面的 $T_0～T_{i-1}$ 執行完成、釋放資源。然後 $T_i$ 可以獲得所需的資源、完成任務、釋放資源並終止。接著換下一個 $T_{i+1}$ 取得它需要的資源，如此下去，直到所有執行緒都完成。若找不到這樣的序列，則系統當前的狀態被稱為**不安全狀態（unsafe state）**。

> [!WARNING] 注意
> - 安全狀態 $≠$ 死結狀態。
> - 死結狀態 $⊂$ 不安全狀態。
> 
> 也就是說，安全狀態一定不會死結，但不安全狀態不一定就是死結。但一旦系統進入不安全狀態，系統就**無法保證未來不會死結**。

在不安全狀態中，系統無法阻止執行緒以一種可能造成死結的方式請求資源。這時系統的命運掌握在執行緒的行為手中。

> [!EXAMPLE]- 範例
> 假設有一個系統，總共有 $12$ 個資源，並有三個執行緒 $T_0$、$T_1$ 和 $T_2$。
> - $T_0$ 最多需要 $10$ 個資源
> - $T_1$ 最多需要 $4$ 個資源
> - $T_2$ 最多需要 $9$ 個資源
> 
> 某時刻 $t_0$，資源分配情況如下：
> ```
> thread = (maximum_needs, current_needs)
> T0 = (10, 5)
> T1 = ( 4, 2)
> T2 = ( 9, 2)
> ```
> 目前系統還有 $12-(5+2+2)=3$ 個可用資源。
> 
> 此時系統處於**安全狀態**，因為存在以下安全序列 $T_1 \rightarrow T_0 \rightarrow T_2$，原因如下：
> - $T_1$ 還需要 $4-2=2$ 個資源，目前有 $3$ 個可分配，夠用，它完成後釋放 $2$ 個資源，系統剩 $5$ 個資源
> - $T_0$ 還需要 $10-5=5$ 個資源，此時可用資源足夠，它完成後釋放 $5$ 個資源，系統剩 $10$ 個資源
> - $T_2$ 還需要 $9-2=7$ 個資源，此時系統有 $10$ 個資源，它也能完成
>  
>  所以這個配置是安全的。

根據「安全狀態」的概念，我們可以設計**避免死結（deadlock avoidance）的演算法，來確保系統永遠不會進入死結狀態**。其核心概念就是：**讓系統始終維持在一個安全狀態**。
1. 一開始，系統處於安全狀態。
2. 當某個執行緒請求一個目前可用的資源時，系統必須做出判斷：
    這個資源是否可以立刻分配給該執行緒？還是該讓它等待？
3. 這個請求**只有在分配後系統仍然處於安全狀態時**，才會被允許。

在這種設計下，即使某個執行緒請求的是**當下有空的資源**，它**也有可能必須等待**，這樣做的副作用是資源的使用率（utilization）可能會比沒有限制時更低，因為有些可用的資源沒有馬上被分配出去，以防系統進入不安全狀態。

#### Banker's Algorithm
銀行家演算法的核心概念其實就是 [[#Safe State]]。

當新的執行緒進入系統時，它**必須宣告它對每種資源最多可能需要的數量**，這個最大值**不得超過系統中該資源的總數量**。當某個執行緒向系統請求一組資源時，系統會先檢查：
> **如果把這些資源分配出去，系統是否仍然處於「安全狀態」？**
- 如果是安全的，資源就會被分配。
- 否則，該執行緒**必須等待**，直到其他執行緒釋放出足夠資源。

銀行家演算法所需的資料結構（假設系統中有 `n` 個執行緒，`m` 種資源類型）：
1. **`Available`**：長度為 `m` 的向量
    代表每種資源當前可用的數量。
    如果 `Available[i][j] = k`，代表資源類型 $R_j$ 有 `k` 個可用。
2. **`Max`**：`n` × `m` 矩陣
    記錄每個執行緒對每種資源的**最大需求**。
    如果 `Max[i][j] = k`，代表執行緒 $T_i$ 最多會需要 `k` 個 $R_j$。
3. **`Allocation`**：`n` × `m` 矩陣
    記錄每個執行緒目前被分配的資源數量。
    如果 `Allocation[i][j] = k`，表示 $T_i$ 已被分配 `k` 個 $R_j$。
4. **`Need`**：`n` ×`m` 矩陣
    記錄每個執行緒還需要多少資源才能完成任務。
    計算方式：`Need[i][j] = Max[i][j] - Allocation[i][j]`。

銀行家演算法由以下兩個演算法組成：
##### Safety Algorithm
這個演算法的目的是根據目前資源分配狀態，判斷是否存在一組「安全執行順序」，讓所有執行緒都能順利完成而不陷入死結。演算法流程如下：

```c 
// pseudo-code
// 1. Let Work and Finish be vectors of length m and n, respectively.

// Initialize
Work = Available;
Finish[i] = false (for i = 0 to n - 1);

// 2. Find an index i that satisifies:
// If no such i exists, goto 4.
Finish[i] == false && Need[i] <= Work

// 3.
Work += Allocation
Finish[i] = true;
// goto 2.

// 4. If the statement is satisified, then the system is in safe state.
Finish[i] == true (for i = 0 to n - 1)
```

這個演算法最多需要執行 $m \times n^2$ 次操作（ $m$ 是資源種類數，$n$ 是 thread 數）。

##### Resource-Request Algorithm
設想某個執行緒 $T_i$ 發出了一個資源請求向量 `Request[i]`：
> 如果 `Request[i][j] == k`，表示執行緒 $T_i$ 要求 $k$ 個 $R_j$ 型資源。

當系統收到這個請求時，依序執行以下步驟：
1. **確認請求是否合理：**
    如果 `Request[i]` ≤ `Need[i]`，進行第 2 步。
    否則，表示執行緒超出了它先前宣告的最大需求，這是錯誤狀況，系統應回報錯誤。
2. 檢查是否有足夠資源可用：
	如果 `Request[i] ≤ Available`，進入第 3 步。
	否則，表示目前資源不足，執行緒 $T_i$ 必須等待。
3. **系統暫時「模擬」資源分配給 $T_i$**
    這是一個「試探性操作」，會修改系統的資源狀態來進行安全性檢查。
    如果新的狀態是安全的：就**正式授予資源**，請求完成。反之則代表執行緒 $T_i$ 必須等待，並且**還原**這次模擬操作（恢復原本的狀態）。
```c
// pseduo-code
Available = Available - Request[i];
Allocation[i] = Allocation[i] + Request[i];
Need[i] = Need[i] - Request[i];
```

### Deadlock Detection


### Recovery form Deadlock
施工中