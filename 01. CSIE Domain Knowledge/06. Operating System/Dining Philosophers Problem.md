## Introduction
哲學家就餐問題（Dining Philosophers Problem）是在電腦科學中的一個經典問題，用來演示在並行計算中多執行緒同步時產生的問題。

1971年，荷蘭電腦科學家艾茲赫爾·戴克斯特拉提出了一個同步問題，即假設有五台電腦都試圖訪問五份共享的磁帶驅動器。稍後，這個問題被東尼．霍爾重新表述為哲學家就餐問題。這個問題可以用來解釋死結和資源耗盡。

## Problem Statement
假設有五位哲學家圍坐在一張圓形餐桌旁，做以下兩件事情之一：吃飯，或者思考。吃東西的時候，他們就停止思考，思考的時候也停止吃東西。餐桌上有五碗義大利麵，每位哲學家之間各有一支餐叉。因為用一支餐叉很難吃到義大利麵，所以假設哲學家必須用兩支餐叉吃東西。他們只能使用自己左右手邊的那兩支餐叉。哲學家就餐問題有時也用米飯和五根筷子而不是義大利麵和餐叉來描述，因為吃米飯必須用兩根筷子。
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/23/an_illustration_of_the_dining_philosophers_problem.png)

這個問題不考慮義大利麵有多少，也不考慮哲學家的胃有多大。假設兩者都是無限大。

問題在於如何設計一套規則，使得在哲學家們在完全不交談，也就是無法知道其他人可能在什麼時候要吃飯或者思考的情況下，可以在這兩種狀態下永遠交替下去。

### Problems
這個問題的設計目的是為了說明避免[[Deadlock|死結]]（deadlock）所面臨的挑戰。死結是一種系統狀態，在其中，系統無法再推進，也無法完成任何操作。

為了理解這個問題的解法並不直觀，我們可以看看一個看似合理但實際上會失敗的方案。這個方案規定每位哲學家的行為如下：
- 除非左邊的叉子可用，否則就持續思考；當左邊的叉子可用時，拿起它；
- 除非右邊的叉子可用，否則就持續思考；當右邊的叉子可用時，拿起它；
- 當手上同時有兩支叉子時，進食一段固定的時間；
- 吃完後，放下左邊的叉子；
- 接著放下右邊的叉子；
- 然後從頭開始重複這個流程。

按照這樣的指令執行時，可能會出現一種情況：每位哲學家都先拿起了自己左邊的叉子。此時，每個人都在等待右邊的叉子可用，但由於所有人都已佔用了左邊的叉子，導致沒有人能拿到右邊的叉子，整個系統因此陷入停滯，無法繼續——這就是死結。

除了死結以外，資源飢餓（resource starvation）、互斥（mutual exclusion）與活鎖（livelock）也是其他與程序順序與資源存取相關的典型問題。

## Solutions
關於[[Deadlock|死結]]的必要條件與解決方法，請參照[[Deadlock#Necessary Conditions|這裡]]。

### Resource Hierarchy Solution
這種解法則是透過否定循環等待（Circular Wait）來解決問題。具體做法是：為所有資源（也就是叉子）指定一個部分排序（partial order），並建立一個規則：所有資源必須依照順序被請求，而且同一單位的工作（例如一位哲學家）同時使用的資源不能彼此無序。

在這個例子中，五支叉子分別編號 $1$ 到 $5$。每位哲學家會先拿編號較小的叉子，再拿編號較大的叉子（以他左右兩支叉子中的較小者開始）。放下叉子的順序則不拘。

這樣設計的結果是：如果有四位哲學家同時拿起較小編號的叉子，那麼只會剩下一支編號最高的叉子還在桌上，這樣第五位哲學家就無法拿到任何叉子。這個方法可以直觀地理解為：餐桌上有一位「左撇子」哲學家，他與其他人不同，總是先從左手邊拿起叉子。

雖然這種「資源階層」的方式可以避免死結，但它不總是實用的，特別是在事前無法完全預知所需資源的情況下。舉例來說：若某個工作單位已經取得了資源 $3$ 和 $5$，之後發現還需要資源 $2$，則它必須先釋放 $5$，再釋放 $3$，然後才能取得 $2$，最後還得重新依序取得 $3$ 和 $5$。對於需要存取大量資料庫記錄的程式而言，這樣的流程效率太低，因此在這類應用場景下並不實用。

此外，這種解法也不是公平的。如果哲學家 $1$ 取叉子的動作比較慢，而哲學家 $2$ 思考與再度取叉子的速度很快，那麼哲學家 1 可能永遠無法同時拿到兩支叉子。所謂的公平解法（fair solution），必須能保證：無論某位哲學家的速度多慢，他最終都一定能吃到東西。

> [!NOTE] TL;DR
> 方法直覺、簡單，但不適用於所有情境。

### Arbitrator Solution
另一種方法是透過引入**仲裁者（如服務生 waiter）**，來保證哲學家只能**同時拿起兩支叉子，或是完全不拿**，以此來取代原先的循環等待（Circular Waiting）問題。

哲學家在拿叉子前**必須先獲得服務生的許可**。服務生一次只允許一位哲學家取得叉子，直到他成功拿到兩支為止。放下叉子則不需要許可，可以隨時進行。

這位服務生可以透過 **互斥鎖（Mutex）來實作。不過，這種方法除了引入了一個中央實體（central authority）之外，也會降低系統的並行性**：如果某位哲學家正在用餐，而他的一位鄰居正在等待叉子，那麼即便其他哲學家的叉子是可用的，也必須等待該請求處理完畢。

> [!NOTE] TL;DR
> 實作方面較為簡單，但犧牲了並行性。

### Limiting the Number of Diners
這種方法的想法是：在任意時刻，最多只允許 **$n−1$ 位哲學家**同時坐下來用餐（$n$ 是哲學家總數）。最後一位哲學家必須等待（例如使用**信號量 Semaphore**）其他人完成用餐，才「坐下」並請求叉子。

這種做法**破壞了循環等待條件（Circular Wait）**，因為至少會有一位哲學家能夠同時拿到兩支叉子，進而讓整個系統持續前進、不停滯。

> [!NOTE] TL;DR
> 操作方便但不夠公平，可能會有哲學家處於飢餓狀態。
### Chandy/Misra Solution
在 1984 年，K. Mani Chandy 與 J. Misra 提出了一種不同於 Dijkstra 解法的方式，用來處理任意數量的代理人（例如哲學家 $P_1$ 到 $P_n$）爭奪任意數量的資源。

這種方法具備以下特色：
- 是完全分散式（distributed）的；
- 初始化後不需要中央控制者；
- 違反了「哲學家彼此不交談」的假設，因為哲學家之間會傳遞請求訊息。

其核心機制如下：
1. 每對爭奪某資源的哲學家之間會有一支叉子，並把叉子一開始交給編號較小的哲學家；
2. 每支叉子有乾淨（clean）或骯髒（dirty）兩種狀態，一開始全部是骯髒的；
3. 當哲學家想吃飯時，他必須從鄰居那裡請求他缺少的叉子；
4. 若哲學家收到請求，且叉子是骯髒的，他會**先把叉子清乾淨再交出去**；如果是乾淨的，他可以保留；
5. 吃完後，哲學家手上的所有叉子變成骯髒的；若之前有人請求過，他會**清潔並歸還該叉子**。

這種方法允許**高度併發性**，且可以解決**任意規模的問題**。此外，這個方法也能解決**飢餓問題（starvation）**。乾淨與骯髒的狀態提供了一種偏好機制：剛吃飽的哲學家會讓位給其他飢餓的哲學家，類似於「不能連續吃兩次」的公平策略。

他們的分析指出，叉子的分布與其乾淨/骯髒狀態會形成一個**偏好圖（preference graph）**，這個圖是**有向無環圖（DAG）**。只要圖保持無環狀態，就不會發生死結。然而，如果初始狀態是完全對稱的（例如每個哲學家都持有左邊的叉子），那麼圖一開始就是有環的，這種狀態就可能導致死結。

為了解決這個問題，只要在初始化時讓**編號較小的哲學家持有骯髒的叉子**，就能保證整個系統一開始是無環的。

> [!NOTE] TL;DR
> 靈活且適用於大規模系統，但實作較複雜

### Dijkstra's Solution (Optional)
Dijkstra 的解法透過**否定佔有等待（Hold and Wait）來避免死結：哲學家要嘛一次性地原子操作取得兩支叉子**，要嘛就完全不拿叉子、繼續等待，絕不會只拿其中一支叉子然後停在臨界區（Critical Section）外。

為了達成這個目的，Dijkstra 的解法使用了：
- 一個**互斥鎖（mutex）**
- 每位哲學家一個**信號量（semaphore）**
- 每位哲學家一個**狀態變數（state variable）**

這種方法比起「資源階層（Resource Hierarchy Solution）」的解法來說**更為複雜**。

> [!NOTE] TL;DR
> 偏向理論解，且實作複雜。
