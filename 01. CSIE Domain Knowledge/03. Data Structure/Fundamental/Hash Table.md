## Introduction
雜湊表（Hash Table），又稱散列表，它透過建立鍵 `key` 與值 `value` 之間的對映，實現高效的元素查詢。具體而言，我們向雜湊表中輸入一個鍵 `key` ，則可以在 $O(1)$ 時間內獲取對應的值 `value` 。除雜湊表外，陣列和鏈結串列也可以實現查詢功能。它們的效率對比如下表：

|      |          陣列           |         鏈結串列          |          雜湊表          |
| ---- | :-------------------: | :-------------------: | :-------------------: |
| 查詢元素 | $\color{#FF2F6C}O(n)$ | $\color{#FF2F6C}O(n)$ | $\color{#B9E06A}O(1)$ |
| 新增元素 |        $O(1)$         |        $O(1)$         |        $O(1)$         |
| 刪除元素 | $\color{#FF2F6C}O(n)$ | $\color{#FF2F6C}O(n)$ | $\color{#B9E06A}O(1)$ |

## Common Operations
> [!CAUTION] 由於 C 未內建雜湊表，以下常見操作不提供 C 的程式碼。

### Initializing
~~~~tabs

tab: C++
```cpp
/* 初始化雜湊表 */
// 在 C++ 中，我們使用 Map 來實現。
unordered_map<int, string> map;
```
tab: Python
```python
# 初始化雜湊表
# 在 Python 中，我們使用內建的字典（Dictionary）來實現。
hmap: dict = {}
```
~~~~

### Querying
~~~~tabs

tab: C++
```cpp
/* 查詢操作 */
// 向雜湊表中輸入鍵 key ，得到值 value
string name = map[15937];
```
tab: Python
```python
# 查詢操作
# 向雜湊表中輸入鍵 key ，得到值 value
name: str = hmap[15937]
```
~~~~

### Adding key-value pairs
~~~tabs
tab: C++
```cpp
/* 新增操作 */
// 在雜湊表中新增鍵值對 (key, value)
map[12836] = "小哈";
map[15937] = "小囉";
map[16750] = "小算";
map[13276] = "小法";
map[10583] = "小鴨";
```

tab: Python
```python
# 新增操作
# 在雜湊表中新增鍵值對 (key, value)
hmap[12836] = "小哈"
hmap[15937] = "小囉"
hmap[16750] = "小算"
hmap[13276] = "小法"
hmap[10583] = "小鴨"
```
~~~

### Deleting key-value pairs
刪除鍵值只需要 `key` 一個參數。
~~~tabs
tab: C++
```cpp
/* 刪除操作 */
// 在雜湊表中刪除鍵值對 (key, value)
map.erase(10583);
```

tab: Python
```python
# 刪除操作
# 在雜湊表中刪除鍵值對 (key, value)
hmap.pop(10583)
```
~~~

### Traversing
雜湊表有三種常用的走訪方式：走訪鍵值對、走訪鍵和走訪值。
~~~~tabs

tab: C++
```cpp
/* 走訪雜湊表 */
// 走訪鍵值對 key->value
for (auto kv: map) {
    cout << kv.first << "->" << kv.second << endl;
}
// 使用迭代器走訪 key->value
for (auto iter = map.begin(); iter != map.end(); iter++) {
    cout << iter->first << "->" << iter->second << endl;
}
```
tab: Python
```python
# 走訪雜湊表
# 走訪鍵值對 key->value
for key, value in hmap.items():
    print(key, "->", value)
# 單獨走訪鍵 key
for key in hmap.keys():
    print(key)
# 單獨走訪值 value
for value in hmap.values():
    print(value)
```
~~~~

## Example: A simple implementation
我們先考慮最簡單的情況，僅用一個陣列來實現雜湊表。在雜湊表中，我們將陣列中的每個空位稱為桶（Bucket），每個桶可儲存一個鍵值對。因此，查詢操作就是找到 `key` 對應的桶，並在桶中獲取 `value` 。

那麼，如何基於 `key` 定位對應的桶呢？這是透過雜湊函式（Hash function）實現的。雜湊函式的作用是將一個較大的輸入空間對映到一個較小的輸出空間。在雜湊表中，輸入空間是所有 `key` ，輸出空間是所有桶（陣列索引）。換句話說，輸入一個 `key` ，**我們可以透過雜湊函式得到該 `key` 對應的鍵值對在陣列中的儲存位置。**

輸入一個 `key` ，雜湊函式的計算過程分為以下兩步。

1. 透過某種雜湊演算法 `hash()` 計算得到雜湊值。
2. 將雜湊值對桶數量（陣列長度）`capacity` 取模，從而獲取該 `key` 對應的陣列索引 `index` 。

```python
index = hash(key) % capacity
```

隨後，我們就可以利用 `index` 在雜湊表中訪問對應的桶，從而獲取 `value` 。

設陣列長度 `capacity = 100`、雜湊演算法 `hash(key) = key` ，易得雜湊函式為 `key % 100` 。下圖以 `key` 學號和 `value` 姓名為例，展示了雜湊函式的工作原理。
![[Drawing - Hash table|100%x500]]

## Hash Collision and Hash Overflow
從本質上看，雜湊函式的作用是將所有 `key` 構成的輸入空間對映到陣列所有索引構成的輸出空間，而輸入空間往往遠大於輸出空間。因此，**理論上一定存在「多個輸入對應相同輸出」的情況**。

對於上述示例中的雜湊函式，當輸入的 `key` 後兩位相同時，雜湊函式的輸出結果也相同。例如，查詢學號為 1283 和 2083 的兩個學生時，我們得到：

```Python
12836 % 100 = 36
20336 % 100 = 36
```

兩個學號指向了同一個 `value`，這顯然是不對的。我們將這種多個輸入對應同一輸出的情況稱為雜湊碰撞（Hash Collision）。當雜湊發生碰撞時，且沒有位置放置新的值時，稱為雜湊溢位（Hash overflow）。首先先審視一下，雜湊函數是否可以重新設計。若使用其他雜湊函數也解決不了問題，可以利用以下方法。

### Seperating chaining
鏈結法（Sperating chaining）使用[[Linked List]]分別儲存每個索引的所有鍵值對。也就是說，當雜湊表遇到衝突時，此方法會將新出現的鍵值對加入對應雜湊的鏈結串列。但是相對應的，該發法使用了較多的空間。在空間資源緊缺的情形下，可以改用開放定址法。

### Open addressing
開放定址法（Open addressing）比其他解決雜湊表衝突的方法更節省空間，例如上面提到的鏈結法。在開放定址法中，當發生衝突時，算法會在雜湊表中探測可用的槽（Slot），找出候補位置，如果滿了再往下尋找，直到找到空的位址。探測可用的槽有以下幾種方式：
#### Linear probing
線性探測（Linear probing）是一個用來解決碰撞的策略，其將新鍵值（也可能只操作鍵，具體要看如何實作線性探測）丟進最靠近碰撞的下一個可用槽中。當多個鍵映射到同一個值的時候，會導致某個槽附近有多個槽位被佔用，進而使得後續的鍵值將繼續在這個區域內尋找空位，從而加劇了該區域的擁擠程度。這種情況會造成查找時間的增加，因為需要檢查更多的連續位置才能找到所需的鍵或空位。我們將這個現象稱為「Primary clustering 」。

#### Quadratic probing
相較於線性探測使用的單純方法，二次探測（Quadratic probing）使用一元二次函數作為尋找下一個可用槽的標準。公式如下：
$$h(k,i) = (h'(k)+c_1 \cdot i+c_2 \cdot i^2) \mod m$$
其中，
- $h'(k)$ 是原先雜湊函數**算出來的值**。
- $i$ 是探測次數（從 $0$ 開始遞增）。
- $c_1$ 與 $c_2$ 是常數，可自定義，通常取 $c_1 = c_2 = 0.5$ 。
- $m$ 是雜湊表的大小。
這樣的設計使得每次探測的步長是二次增長的，從而使得探測序列更為分散，有助於避免Primary clusteing。但是，這並不代表二次探測不會引發聚集問題。

假設兩個不同的鍵值經過雜湊函式計算後得到相同的槽位，它們在後續探測過程中會遵循相同的探測序列。因此，即使它們最初的位置不同，它們在探測過程中仍然會進入相同的索引序列。我們將這個現象稱為「Secondary clustering 」。

如果要避免「聚集」的發生，可以使用以下方法：
#### Rehashing
再雜湊法（Rehashing）發生碰撞時使用另一個雜湊函數重新計算元素的哈希值。這樣可以確保具有相同初始哈希值的元素不會聚集在一起，從而減少聚集的可能性。

#### Double hashing
雙重雜湊法（Double hashing）在發生碰撞時使用第二個雜湊函數**計算新的探測步長**。這樣即使兩個鍵有相同的初始雜湊值，它們也會按照不同的步長探測，從而減少聚集現象。

## Resizing
如果雜湊表變得太滿，使用開放定址法會導致性能下降。由於隨著表中佔用槽的數量增加，衝突次數也隨之增加，這意味著必須探測更多索引以找到可用槽，導致更長的查找時間和性能下降。

類似於陣列擴容，雜湊表擴容需將所有鍵值對從原雜湊表遷移至新雜湊表，非常耗時；並且由於雜湊表容量 `capacity` 改變，我們需要透過雜湊函式來重新計算所有鍵值對的儲存位置，這進一步增加了擴容過程的計算開銷。為此，程式語言通常會預留足夠大的雜湊表容量，防止頻繁擴容。

負載因子（Load factor）是雜湊表的一個重要概念，其定義為：
$$\frac{桶數量}{雜湊表的元素數量}$$
用於衡量雜湊衝突的嚴重程度，**也常作為雜湊表擴容的觸發條件**。例如在 Java 中，當負載因子超過 $0.75$ 時，系統會將雜湊表擴容至原先的 $2$ 倍。

## Q & A
> [!QUESTION]- 雜湊表的時間複雜度在什麼情況下是 $O(n)$？
> 當雜湊碰撞比較嚴重時，雜湊表的時間複雜度會退化至 $O(n)$。當雜湊函式設計得比較好、容量設定比較合理、衝突比較平均時，時間複雜度是$O(1)$。我們使用程式語言內建的雜湊表時，通常認為時間複雜度是$O(1)$。

> [!QUESTION]- 為什麼不使用雜湊函式 $f(x)=x$ 呢？這樣就不會有衝突了。
> 在 $f(x)=x$ 雜湊函式下，每個元素對應唯一的桶索引，這與陣列等價。然而，輸入空間通常遠大於輸出空間（陣列長度），因此雜湊函式的最後一步往往是對陣列長度取模。換句話說，雜湊表的目標是將一個較大的狀態空間對映到一個較小的空間，並提供 $O(1)$ 的查詢效率。

> [!QUESTION]- 雜湊表底層實現是陣列、鏈結串列、二元樹，但為什麼效率可以比它們更高呢？
> 首先，雜湊表的時間效率變高，但空間效率變低了。雜湊表有相當一部分記憶體未使用。
> 其次，只是在特定使用場景下時間效率變高了。如果一個功能能夠在相同的時間複雜度下使用陣列或鏈結串列實現，那麼通常比雜湊表更快。這是因為雜湊函式計算需要開銷，時間複雜度的常數項更大。
> 最後，雜湊表的時間複雜度可能發生劣化。例如在鏈式位址中，我們採取在鏈結串列或紅黑樹中執行查詢操作，仍然有退化至 $O(n)$ 時間的風險。

> [!QUESTION]- 多次雜湊（Multiple hashing）有不能直接刪除元素的缺陷嗎？標記為已刪除的空間還能再次使用嗎？
> 多次雜湊是開放定址的一種，開放定址法都有不能直接刪除元素的缺陷，需要透過標記刪除。標記為已刪除的空間可以再次使用。當將新元素插入雜湊表，並且透過雜湊函式找到標記為已刪除的位置時，該位置可以被新元素使用。這樣做既能保持雜湊表的探測序列不變，又能保證雜湊表的空間使用率。

> [!QUESTION]- 為什麼在線性探查中，查詢元素的時候會出現雜湊衝突呢？
> 查詢的時候透過雜湊函式找到對應的桶和鍵值對，發現 `key` 不匹配，這就代表有雜湊衝突。因此，線性探查法會根據預先設定的步長依次向下查詢，直至找到正確的鍵值對或無法找到跳出為止。

> [!QUESTION]- 為什麼雜湊表擴容能夠緩解雜湊衝突？
> 雜湊函式的最後一步往往是對陣列長度 $n$ 取$\mod{}$（`%`），讓輸出值落在陣列索引範圍內；在擴容後，陣列長度 $n$ 發生變化，而 `key` 對應的索引也可能發生變化。原先落在同一個桶的多個 `key` ，在擴容後可能會被分配到多個桶中，從而實現雜湊衝突的緩解。


