## Definition
在作業系統教科書之間有聖經之稱的「Operating System Concepts 10th Edition（恐龍本）」中，對死結（Deadlock）的定義如下：
> 在**多重程式設計（multiprogramming）的環境中，多個執行緒（threads）可能會競爭有限的資源。當某個執行緒請求資源時，若該資源當下無法取得，該執行緒便會進入等待狀態（waiting state）**。有時候，某個等待中的執行緒可能**永遠無法改變其狀態**，因為它所請求的資源被**其他同樣處於等待狀態的執行緒所持有**。

以較為直觀的角度來看的話：
> 在作業系統中，死結是指：當一個行程（process）或執行緒（thread）進入等待狀態時，其所要求的系統資源被另一個處於等待狀態的行程所持有，而那個行程又在等待另一個資源，該資源則被另一個等待中的行程持有，形成一連串相互等待的狀態。如果一個行程**無法永遠改變其狀態**，原因是它所要求的資源**被另一個同樣處於等待狀態的行程佔用**，那麼就稱系統進入了**死結狀態（deadlock state）**。

### A Simple Example
例如，一個行程 $\text{P1}$ 占用了顯示器，同時又必須使用印表機，而印表機被行程 $\text{P2}$ 占用，$\text{P2}$ 又必須使用顯示器，這樣就形成了死結。 因為 $\text{P1}$ 必須等待 $\text{P2}$ 釋出印表機才能夠完成工作並釋出螢幕，同時 $\text{P2}$ 也必須等待 $\text{P1}$ 釋出顯示器才能完成工作並釋出印表機，形成循環等待的死結。

![](https://upload.wikimedia.org/wikipedia/commons/thumb/2/28/Process_deadlock.svg/440px-Process_deadlock.svg.png)
$\text{P1}$、$\text{P2}$ 兩個 process 都需要資源才能繼續執行。$\text{P1}$ 擁有資源 $\text{R2}$、還需要額外資源 $\text{R1}$ 才能執行；$\text{P2}$ 擁有資源 $\text{R1}$、還需要額外資源 $\text{R2}$ 才能執行，兩邊都在互相等待而沒有任何一個可執行。

## Necessary Conditions
要讓死結發生，必須同時滿足以下四個充分必要條件：
這四個條件有時候會被稱為科夫曼條件（Coffman Conditions）。
1. **互斥（Mutual Exclusion）**
    至少有一個資源是在不可分享狀態下被佔用。也就是說，一次只能有一個 thread 可以使用資源。如果其他 thread 想要使用這項資源，就只能等到這項資源被使用者釋放。
2. **佔有等待（Hold and Wait）**
    一個 thread 手中必須已經持有一項資源，且，同時在等待另一項正在被其他 thread 使用的資源。
3. **不可搶奪（No Preemption, or Non-Preemption）**
    資源皆是不可被搶奪的。換句話說，就是資源只能在 thread 完成一個 task 後，以自願的方式釋放。
4. **循環等待（Circular Wait）**
    有一組正在等待資源的 threads $\{ T_0, T_1, \cdots, T_n\}$ ，滿足：
     - $T_0$ 在等待 $T_1$ 手中的資源
     - $T_1$ 在等待 $T_2$ 手中的資源
     - $\vdots$
     - $T_{n-1}$ 在等待 $T_n$ 手中的資源
     - $T_n$ 在等待 $T_0$ 手中的資源
    
    從上述描述來看，不難發現：此條件滿足時，代表佔有等待也必定滿足。（循環等待是資源保持的充分條件）

若要解決死結問題，必須**破壞上述四個條件中的至少一個**。在實作中，某些方法會嘗試破壞「互斥」或「不可搶奪」的條件，以找到有效的解法；但在大多數理論性的探討中，這兩個條件通常被視為**不可妥協**（不可避免或必須維持的假設），因此解法通常會著重於破壞「資源保持」或「循環等待」這兩個條件（有時是同時破壞這兩個）。

## Deadlock Handling
對於死結的處理方式，可以大致歸類為以下三種：
1. 完全忽略這個問題，假裝系統中不會發生死結。
2. 採用某種協定（protocol）來預防或避免死結，以確保系統永遠不會進入死結狀態。
3. 允許系統進入死結狀態，然後再進行偵測與恢復。

### Ignoring Deadlock
忽略死結是大多數作業系統（包括 Linux 和 Windows）所採用的做法。這種情況下，就需要 Kernel 與應用程式開發者負責撰寫能夠處理死結的程式，這類程式通常會採用第二種解法中所提到的預防或避免方法。

為了**確保系統永遠不會發生死結**，可以採用死結預防（deadlock prevention）或死結避免（deadlock avoidance）的機制。

### Deadlock Prevention
死結預防提供了一套方法，用來確保死結發生所需的條件中，至少有一項無法成立。這些方法透過**限制資源請求的方式**來達到預防死結的目的。

> [!NOTE] TL;DR
> 避免循環等待是最實際且有效的解決方法。 詳見[[#Circular Wait]]。

#### Mutual Exclusion
互斥條件必須成立，也就是至少有一項資源是無法共享的。可共享的資源不需要互斥存取，因此無法導致死結。

像是唯讀檔案（read-only files）就是一種可共享資源。如果多個執行緒同時開啟一個唯讀檔案，它們可以被同時授予存取權限，不會互相阻塞。對於可共享的資源，執行緒永遠不需要等待。
  
然而，一般來說，**我們無法透過否定互斥條件來預防死結，因為某些資源本質上就是無法共享的**。例如：互斥鎖（Mutex lock） 無法被多個執行緒同時持有。

#### Hold and Wait
為了確保系統中永遠不會出現「佔有且等待」的情況，我們必須保證當執行緒請求資源時，它不持有任何其他資源。

有一種協定是：
>每個執行緒在開始執行之前，必須先請求並獲得它所需要的所有資源。
>但對大多數情況來說，這並不切實際，因為資源需求往往是動態變化的。

另一種協定則是：
>執行緒只能在完全沒有持有資源時才能請求資源。
>也就是說，執行緒可以請求一部分資源並使用；但在它要請求其他資源之前，必須先釋放它目前持有的所有資源。

然而，這兩種協定都有兩個主要缺點：
1. **資源使用率可能偏低**
    因為有些資源可能被分配出去，但長時間都沒被實際使用。例如，一個執行緒可能在整個執行期間都被分配了一把互斥鎖，但實際上只在某一小段時間內需要它。
2. **可能發生飢餓（Starvation）**
    如果一個執行緒需要多個熱門資源，它可能**一直等不到所有資源都可用**，因為其中至少有一個資源總是被其他執行緒佔用。

#### No Preemptive
死結的第三個必要條件是：**已經被分配的資源無法被搶奪。

為了讓這個條件不成立，我們可以採用以下協定：
> 如果某個執行緒目前**持有一些資源**，並且又請求**另一個目前無法立即分配的資源**（也就是說，它必須等待），那麼**它目前持有的所有資源都會被搶回**。

換句話說，這些資源會被**隱式釋放**，並被加入執行緒所等待的資源清單中。
這個執行緒**只有在它能夠一次性取得原本的資源加上新請求的資源時，才會重新啟動執行**。

另一種做法是這樣的：
> 當某個執行緒請求一些資源時，我們會先檢查這些資源是否可用：
> - 如果可用，就直接分配給它。
> - 如果不可用，我們再檢查這些資源是否**被某個正在等待其他資源的執行緒所持有**。
>     如果是這樣，我們會**從那個等待的執行緒手中搶下這些資源**，並分配給目前的請求者。
> - 如果這些資源**既不可用、也不是由等待中的執行緒持有**，那麼請求者就必須等待。
>     在等待的過程中，這個執行緒**本身持有的資源也可能會被其他執行緒搶走**，但**只有在有其他執行緒明確請求這些資源的情況下才會發生**。

一個執行緒只有在同時取得它新請求的資源，以及**所有在等待期間被搶走的資源**後，才會重新啟動。這種協定**通常適用於那些可以輕鬆儲存與還原狀態的資源**，例如 CPU 暫存器或資料庫交易（transactions）。但它**不太適用於像是互斥鎖（Mutex）或是信號量（Semaphore）這類資源**，而這些正是最容易發生死結的資源類型。

#### Circular Wait
前面介紹的三種防止死結的方法，在多數情況下都不太實用。然而，**死結的第四個必要條件 —— 循環等待（circular-wait）**，提供了一個更實際的解決方案：**讓這個條件不成立，就能有效預防死結**。

其中一種方式是：
> **對所有資源類型施加一個**「**總體排序（total ordering）**」，並要求每個執行緒只能按照這個排序，以**遞增的順序請求資源**。

為了說明這個方法，我們令資源集合為：$R = \{R_1, R_2, \cdots, R_m\}$。我們為集合中的每個資源類型指定一個唯一的整數編號，使我們能夠比較任意兩個資源，判斷它們在排序中的先後關係。形式上，我們定義一個一對一的函數：$F: R \rightarrow N$，其中 $N$ 是自然數集合。這個函數可以在應用程式中被實作，用來對系統中的所有同步物件建立一個排序。例如，對於以下 `Pthread` 程式中的鎖順序，我們可以定義：
```
F(first_mutex) = 1
F(second_mutex) = 5
```

接著，我們可以使用如下協定來防止死結：
> 每個執行緒只能**按照遞增的資源編號順序來請求資源**。也就是說，假設某執行緒首先請求資源 $R_j$，那麼它之後只能請求資源 $R_k$，前提是 $F(R_k) > F(R_j)$。

例如，根據上述函數定義，如果一個執行緒需要同時使用 `first_mutex` 與 `second_mutex`，那它必須**先請求 `first_mutex`，然後才能請求 `second_mutex`**。

另一種替代做法是：
> 若執行緒請求資源$R_j$，則它**不能持有任何資源 $R_k$，滿足 $F(R_k) > F(R_j)$**。

此外，如果執行緒**需要同一類資源的多個實例**，那麼它**必須一次性請求全部**。如果系統遵守上述兩種協定之一，就能保證**循環等待的條件不會成立**。

> [!TIP]- 為了展示以上內容的正確性，以下用反證法舉例證明：
> 假設某系統中存在一組陷入循環等待的執行緒集合：
> $T = \{T_0, T_1, \cdots, T_n\}$
> 
> 其中每個執行緒 $T_i$ 正在等待資源 $R_i$，而該資源被執行緒 $T_{i+1}$ 所持有
> （索引以模運算處理，即 $T_n$ 等同於 $T_0$ 的前一個）。
> 
> 由於 $T_{i+1}$ 正持有 $R_i$ 並請求 $R_{i+1}$，根據前述協定，我們必須有：
> $F(R_i) < F(R_{i+1}), \forall \space i$
> 
> 由遞移性，可以推得 ：
> $F(R_0) < F(R_n) < F(R_0)$
> 但是這在數學上是**不可能成立**的。
> 
> 因此推翻了原假設：**系統中不可能存在循環等待**。

> [!WARNING] 注意
> **僅僅建立這樣的資源排序（或資源階層）本身**並不能真正防止死結。
> 最終仍然必須靠**應用程式開發者遵循這個順序編寫程式碼**。
> 
> 此外，也必須特別注意，即使我們對鎖設定了取得順序，若鎖是以動態方式取得的（例如在不同邏輯路徑或函式中動態請求），這樣的排序也 不能保證完全避免死結。

但在實務上，這一點也頗具挑戰性。特別是在一個有數百甚至數千個鎖的系統中，要正確建立並遵守鎖順序是困難的。

### Deadlock Avoidance
 死結避免則要求作業系統事先獲得額外的資訊，包括每個執行緒在其整個生命週期中可能會**請求與使用哪些資源**。有了這些額外資訊後，作業系統就可以針對每一個資源請求**決定該不該讓執行緒等待**。為了判斷當前的請求是否可以被滿足，或者是否必須延遲，系統必須考量以下幾個因素：
- 當前可用的資源
- 已分配給每個執行緒的資源
- 每個執行緒未來的資源請求與釋放情形

### Deadlock Detection


### Recovery form Deadlock
施工中