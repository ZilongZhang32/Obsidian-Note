## Definition
### Operating System Concepts 10th edition
在**多重程式設計（multiprogramming）的環境中，多個執行緒（threads）可能會競爭有限的資源。當某個執行緒請求資源時，若該資源當下無法取得，該執行緒便會進入等待狀態（waiting state）**。有時候，某個等待中的執行緒可能**永遠無法改變其狀態**，因為它所請求的資源被**其他同樣處於等待狀態的執行緒所持有**。這種情況就稱為**死結（deadlock）**。

### In a General Perspective
在作業系統中，死結（deadlock）是指：當一個行程（process）或執行緒（thread）進入等待狀態時，其所要求的系統資源被另一個處於等待狀態的行程所持有，而那個行程又在等待另一個資源，該資源則被另一個等待中的行程持有，形成一連串相互等待的狀態。如果一個行程**無法永遠改變其狀態**，原因是它所要求的資源**被另一個同樣處於等待狀態的行程佔用**，那麼就稱系統進入了**死結狀態（deadlock state）**。

## A Simple Example
例如，一個行程 $\text{P1}$ 占用了顯示器，同時又必須使用印表機，而印表機被行程 $\text{P2}$ 占用，$\text{P2}$ 又必須使用顯示器，這樣就形成了死結。 因為 $\text{P1}$ 必須等待 $\text{P2}$ 釋出印表機才能夠完成工作並釋出螢幕，同時 $\text{P2}$ 也必須等待 $\text{P1}$ 釋出顯示器才能完成工作並釋出印表機，形成循環等待的死結。

![](https://upload.wikimedia.org/wikipedia/commons/thumb/2/28/Process_deadlock.svg/440px-Process_deadlock.svg.png)
$\text{P1}$、$\text{P2}$ 兩個 process 都需要資源才能繼續執行。$\text{P1}$ 擁有資源 $\text{R2}$、還需要額外資源 $\text{R1}$ 才能執行；$\text{P2}$ 擁有資源 $\text{R1}$、還需要額外資源 $\text{R2}$ 才能執行，兩邊都在互相等待而沒有任何一個可執行。

## Necessary Conditions
要讓死結發生，必須同時滿足以下四個條件：
1. **互斥（Mutual Exclusion）**
    至少有一個資源是在不可分享狀態下被佔用。也就是說，一次只能有一個 thread 可以使用資源。如果其他 thread 想要使用這項資源，就只能等到這項資源被使用者釋放。
2. **資源保持（Resource Holding）**
    一個 thread 手中必須已經持有一項資源，且，同時在等待另一項正在被其他 thread 使用的資源。
3. **不可搶奪（No Preemption, or Non-Preemption）**
    資源皆是不可被搶奪的。換句話說，就是資源只能在 thread 完成一個 task 後，以自願的方式釋放。
4. **循環等待（Circular Wait）**
    有一組正在等待資源的 threads $\{ T_0, T_1, \cdots, T_n\}$ ，滿足：
     - $T_0$ 在等待 $T_1$ 手中的資源
     - $T_1$ 在等待 $T_2$ 手中的資源
     - $\vdots$
     - $T_{n-1}$ 在等待 $T_n$ 手中的資源
     - $T_n$ 在等待 $T_0$ 手中的資源
    
    從上述描述來看，不難發現：此條件滿足時，代表資源保持也必定滿足。

若要解決死結問題，必須**破壞上述四個條件中的至少一個**。

在實作中，某些方法會嘗試破壞「互斥」或「不可搶奪」的條件，以找到有效的解法；但在大多數理論性的探討中，這兩個條件通常被視為**不可妥協**（不可避免或必須維持的假設），因此解法通常會著重於破壞「資源保持」或「循環等待」這兩個條件（有時是同時破壞這兩個）。